<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>glip: Circular Buffer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">glip
   &#160;<span id="projectnumber">0.1.0-dev</span>
   </div>
   <div id="projectbrief">The Generic Logic Interfacing Project</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>GLIP&#160;Introduction</span></a></li>
      <li><a href="examples.html"><span>Demos</span></a></li>
      <li><a href="modules.html"><span>Documentation</span></a></li>
      <li><a href="download.html"><span>Download</span></a></li>
      <li><a href="contact.html"><span>Contact</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__development-cbuf.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Circular Buffer<div class="ingroups"><a class="el" href="group__development.html">Extending GLIP</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcbuf.html">cbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7d0be4589ed029033229def542e9d68b"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__development-cbuf.html#ga7d0be4589ed029033229def542e9d68b">_cbuf_calc_bufsize</a> (size_t size_req, size_t size_max)</td></tr>
<tr class="separator:ga7d0be4589ed029033229def542e9d68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c2eec48a1f36acd6a1c2b98720cd60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__development-cbuf.html#ga08c2eec48a1f36acd6a1c2b98720cd60">cbuf_init</a> (struct <a class="el" href="structcbuf.html">cbuf</a> **buf, size_t size)</td></tr>
<tr class="separator:ga08c2eec48a1f36acd6a1c2b98720cd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c0b5b3b64ddeb2094ad81e17b9c3072"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__development-cbuf.html#ga5c0b5b3b64ddeb2094ad81e17b9c3072">cbuf_free</a> (struct <a class="el" href="structcbuf.html">cbuf</a> *buf)</td></tr>
<tr class="separator:ga5c0b5b3b64ddeb2094ad81e17b9c3072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82522b71b0c0bbe512795f1d57b5d402"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__development-cbuf.html#ga82522b71b0c0bbe512795f1d57b5d402">cbuf_set_hint_max_read_size</a> (struct <a class="el" href="structcbuf.html">cbuf</a> *buf, size_t hint_max_read_size)</td></tr>
<tr class="separator:ga82522b71b0c0bbe512795f1d57b5d402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb977647a0d6f8795c5bb097044cf4a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__development-cbuf.html#gadb977647a0d6f8795c5bb097044cf4a8">cbuf_set_hint_max_write_size</a> (struct <a class="el" href="structcbuf.html">cbuf</a> *buf, size_t hint_max_write_size)</td></tr>
<tr class="separator:gadb977647a0d6f8795c5bb097044cf4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6476fda2a4b1388367f74d80947068cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__development-cbuf.html#ga6476fda2a4b1388367f74d80947068cd">cbuf_write</a> (struct <a class="el" href="structcbuf.html">cbuf</a> *buf, const uint8_t *data, size_t size)</td></tr>
<tr class="separator:ga6476fda2a4b1388367f74d80947068cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6eb82f033f4cdbc097b75b7a2726c1d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__development-cbuf.html#gae6eb82f033f4cdbc097b75b7a2726c1d">cbuf_reserve</a> (struct <a class="el" href="structcbuf.html">cbuf</a> *buf, uint8_t **data, size_t size)</td></tr>
<tr class="separator:gae6eb82f033f4cdbc097b75b7a2726c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaa163f966a58e2127cb7690971b87d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__development-cbuf.html#gaaaa163f966a58e2127cb7690971b87d9">cbuf_commit</a> (struct <a class="el" href="structcbuf.html">cbuf</a> *buf, uint8_t *data, size_t size)</td></tr>
<tr class="separator:gaaaa163f966a58e2127cb7690971b87d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga428bae4afd36291497a6a8d817c8041a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__development-cbuf.html#ga428bae4afd36291497a6a8d817c8041a">cbuf_read</a> (struct <a class="el" href="structcbuf.html">cbuf</a> *buf, uint8_t *data, size_t size)</td></tr>
<tr class="separator:ga428bae4afd36291497a6a8d817c8041a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2639e46f2942e7e1d37bd6b76d52b4b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__development-cbuf.html#ga2639e46f2942e7e1d37bd6b76d52b4b8">cbuf_peek</a> (struct <a class="el" href="structcbuf.html">cbuf</a> *buf, uint8_t **data, size_t size)</td></tr>
<tr class="separator:ga2639e46f2942e7e1d37bd6b76d52b4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e5c250e57ef3838f11d289d243eb77"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__development-cbuf.html#gab5e5c250e57ef3838f11d289d243eb77">cbuf_discard</a> (struct <a class="el" href="structcbuf.html">cbuf</a> *buf, size_t size)</td></tr>
<tr class="separator:gab5e5c250e57ef3838f11d289d243eb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga658dcd20d427a506c498a8b2795c13a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__development-cbuf.html#ga658dcd20d427a506c498a8b2795c13a5">cbuf_is_empty</a> (struct <a class="el" href="structcbuf.html">cbuf</a> *buf)</td></tr>
<tr class="separator:ga658dcd20d427a506c498a8b2795c13a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35fc94ab1feed8e622c4463d3988ded4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__development-cbuf.html#ga35fc94ab1feed8e622c4463d3988ded4">cbuf_is_full</a> (struct <a class="el" href="structcbuf.html">cbuf</a> *buf)</td></tr>
<tr class="separator:ga35fc94ab1feed8e622c4463d3988ded4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ad5db0ba023348744c080d1bba08cf2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__development-cbuf.html#ga8ad5db0ba023348744c080d1bba08cf2">cbuf_fill_level</a> (struct <a class="el" href="structcbuf.html">cbuf</a> *buf)</td></tr>
<tr class="separator:ga8ad5db0ba023348744c080d1bba08cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga146839d85f4314d7aac1d55fa6721945"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__development-cbuf.html#ga146839d85f4314d7aac1d55fa6721945">cbuf_free_level</a> (struct <a class="el" href="structcbuf.html">cbuf</a> *buf)</td></tr>
<tr class="separator:ga146839d85f4314d7aac1d55fa6721945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac061fbaf4eac2127aee5ac2bfa5177a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__development-cbuf.html#gaac061fbaf4eac2127aee5ac2bfa5177a">cbuf_wait_for_level_change</a> (struct <a class="el" href="structcbuf.html">cbuf</a> *buf)</td></tr>
<tr class="separator:gaac061fbaf4eac2127aee5ac2bfa5177a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9872126868ffb2148641c85cda6e79cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__development-cbuf.html#ga9872126868ffb2148641c85cda6e79cc">cbuf_timedwait_for_level_change</a> (struct <a class="el" href="structcbuf.html">cbuf</a> *buf, const struct timespec *abs_timeout)</td></tr>
<tr class="separator:ga9872126868ffb2148641c85cda6e79cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Inside GLIP it is often necessary to buffer incoming or outgoing data between the read/write API and a communication thread. This functionality is usually accomplished by a circular buffer, a.k.a. ring buffer or FIFO, and implemented in this class.</p>
<p>cbuf supports two methods for reading and writing data, which can be freely intermixed: a basic mode and an API mode.</p>
<h1><a class="anchor" id="basic_mode"></a>
Basic Mode</h1>
<p>The basic mode is exactly what you would expect from a buffer implementation: <a class="el" href="group__development-cbuf.html#ga428bae4afd36291497a6a8d817c8041a">cbuf_read()</a> reads data from the buffer, and <a class="el" href="group__development-cbuf.html#ga6476fda2a4b1388367f74d80947068cd">cbuf_write()</a> allows you to write data to the buffer.</p>
<h1><a class="anchor" id="api_mode"></a>
API Mode</h1>
<p>In addition to the basic mode, cbuf is optimized to be used together with 3rd-party APIs. Those APIs exhibit a common pattern:</p>
<ul>
<li>To read from a device, you pass a pointer to a pre-allocated memory area together with the size of this memory area. Then you call the read function of the API, which writes the data to the memory area you gave and returns the number of actually written bytes.</li>
<li>To write to a device, you pass a pointer to the data you want to write, together with the number of bytes you want to write. Then you call the API function and it returns the number of bytes that have been actually written.</li>
</ul>
<p>Using such an API together with the basic read/write functions requires you to use temporary buffers, which obviously has a memory overhead and (more importantly) requires data to be needlessly copied around, reducing performance. But don't despair, cbuf's API Mode got you covered!</p>
<p>Now, when reading from the device and thus writing into the circular buffer, you do the following:</p>
<ul>
<li>Call <a class="el" href="group__development-cbuf.html#gae6eb82f033f4cdbc097b75b7a2726c1d">cbuf_reserve()</a> to get a pointer to an allocated buffer with enough room for a defined number of bytes.</li>
<li>Call the appropriate function from your API to read from the device, and pass it the pointer you got from <a class="el" href="group__development-cbuf.html#gae6eb82f033f4cdbc097b75b7a2726c1d">cbuf_reserve()</a> together with the size of buffer space you reserved.</li>
<li>When the read function from the device returns with the number of bytes it actually read, call <a class="el" href="group__development-cbuf.html#gaaaa163f966a58e2127cb7690971b87d9">cbuf_commit()</a> to commit the data to the buffer.</li>
</ul>
<p>Reading from the circular buffer works the same way by using the <a class="el" href="group__development-cbuf.html#ga2639e46f2942e7e1d37bd6b76d52b4b8">cbuf_peek()</a> and <a class="el" href="group__development-cbuf.html#gab5e5c250e57ef3838f11d289d243eb77">cbuf_discard()</a> functions.</p>
<p>Note that you will get always a continuous block of memory when calling <a class="el" href="group__development-cbuf.html#gae6eb82f033f4cdbc097b75b7a2726c1d">cbuf_reserve()</a> or <a class="el" href="group__development-cbuf.html#ga2639e46f2942e7e1d37bd6b76d52b4b8">cbuf_peek()</a>, as long as the buffer fill level allows for it.</p>
<p>The implementation of cbuf tries to avoid copying data whenever possible (which is actually most of the time). Internally, though, the circular buffer is implemented as block of memory with begin and end pointers. This creates cases where a single write to the buffer causes actually two writes, one to the end of the buffer space, and on to the beginning. In this case a temporary buffer is handed out by <a class="el" href="group__development-cbuf.html#gae6eb82f033f4cdbc097b75b7a2726c1d">cbuf_reserve()</a> and this buffer is later on copied to the appropriate destinations (when calling <a class="el" href="group__development-cbuf.html#gaaaa163f966a58e2127cb7690971b87d9">cbuf_commit()</a>). The same logic applies to the read operation appropriately.</p>
<p>Implementations exist which in all cases avoid copying data, usually with the trade-off of not being able to use the whole buffer space in all cases, i.e. you cannot always fill the circular buffer up to 100 percent. One such implementation is the <a href="http://www.codeproject.com/Articles/3479/The-Bip-Buffer-The-Circular-Buffer-with-a-Twist">Bip Buffer</a> by Simon Cooke.</p>
<h1><a class="anchor" id="thread_safety"></a>
Thread Safety</h1>
<p>A circular buffer has two "sides": a read side and a write side. In many cases reading happens from a different thread than writing. This use case is fully supported by cbuf, and read and write side are properly synchronized by appropriate locking mechanisms. Note, however, that cbuf is not fully thread safe. You cannot, for example, write to the buffer from two different threads without implementing appropriate locking mechanisms yourself. This keeps the synchronization overhead minimal while allowing for the most common use case.</p>
<ul>
<li>Functions of the read side: <a class="el" href="group__development-cbuf.html#ga428bae4afd36291497a6a8d817c8041a">cbuf_read()</a>, <a class="el" href="group__development-cbuf.html#ga2639e46f2942e7e1d37bd6b76d52b4b8">cbuf_peek()</a>, <a class="el" href="group__development-cbuf.html#gab5e5c250e57ef3838f11d289d243eb77">cbuf_discard()</a></li>
<li>Functions of the write side: <a class="el" href="group__development-cbuf.html#ga6476fda2a4b1388367f74d80947068cd">cbuf_write()</a>, <a class="el" href="group__development-cbuf.html#gae6eb82f033f4cdbc097b75b7a2726c1d">cbuf_reserve()</a>, <a class="el" href="group__development-cbuf.html#gaaaa163f966a58e2127cb7690971b87d9">cbuf_commit()</a></li>
</ul>
<h1><a class="anchor" id="utility"></a>
Utility Functionality</h1>
<p>cbuf contains, in addition to the read/write API, a number of useful utility functions.</p>
<ul>
<li>Information about the fill level: <a class="el" href="group__development-cbuf.html#ga146839d85f4314d7aac1d55fa6721945">cbuf_free_level()</a>, <a class="el" href="group__development-cbuf.html#ga8ad5db0ba023348744c080d1bba08cf2">cbuf_fill_level()</a>, <a class="el" href="group__development-cbuf.html#ga658dcd20d427a506c498a8b2795c13a5">cbuf_is_empty()</a>, and <a class="el" href="group__development-cbuf.html#ga35fc94ab1feed8e622c4463d3988ded4">cbuf_is_full()</a></li>
<li>Blocking waiting until the fill level changes: <a class="el" href="group__development-cbuf.html#gaac061fbaf4eac2127aee5ac2bfa5177a">cbuf_wait_for_level_change()</a> and <a class="el" href="group__development-cbuf.html#ga9872126868ffb2148641c85cda6e79cc">cbuf_timedwait_for_level_change()</a></li>
<li>Optimizations: <a class="el" href="group__development-cbuf.html#ga82522b71b0c0bbe512795f1d57b5d402">cbuf_set_hint_max_read_size()</a> and <a class="el" href="group__development-cbuf.html#gadb977647a0d6f8795c5bb097044cf4a8">cbuf_set_hint_max_write_size()</a> </li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7d0be4589ed029033229def542e9d68b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t _cbuf_calc_bufsize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate a new buffer size</p>
<p>The new size is the next power of two following <code>size_req</code>, but at most <code>size_max</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size_req</td><td>the requested buffer size </td></tr>
    <tr><td class="paramname">size_max</td><td>the maximum buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the calculated buffer size </dd></dl>

</div>
</div>
<a class="anchor" id="ga08c2eec48a1f36acd6a1c2b98720cd60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cbuf_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcbuf.html">cbuf</a> **&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer structure to be initialized </td></tr>
    <tr><td class="paramname">size</td><td>the size of the buffer in bytes. The size needs to be a power of two. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-ENOMEM if the memory allocation for the data buffer failed </dd>
<dd>
any other value indicates an error </dd></dl>

</div>
</div>
<a class="anchor" id="ga5c0b5b3b64ddeb2094ad81e17b9c3072"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cbuf_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcbuf.html">cbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free all resources of the buffer</p>
<p>This function frees all resources inside the buffer, including the buffer struct <code>buf</code> itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
any other value indicates an error </dd></dl>

</div>
</div>
<a class="anchor" id="ga82522b71b0c0bbe512795f1d57b5d402"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cbuf_set_hint_max_read_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcbuf.html">cbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hint_max_read_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Give a hint on the maximum read size</p>
<p>Reading from the circular buffer requires under some circumstances the use of a temporary buffer. This buffer needs to be as large as a read size and automatically adjusts its size. If you know already how large your maximum read will be (e.g. your maximum packet size), you can set this value as a hint and this way prevent unnecessary memory allocations.</p>
<p>Note that this hint is strictly an optimization, it's not necessary for the correct functioning of this buffer!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer </td></tr>
    <tr><td class="paramname">hint_max_read_size</td><td>a hint on the maximum read size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
any other value indicates an error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__development-cbuf.html#gadb977647a0d6f8795c5bb097044cf4a8">cbuf_set_hint_max_write_size()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadb977647a0d6f8795c5bb097044cf4a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cbuf_set_hint_max_write_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcbuf.html">cbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hint_max_write_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Give a hint on the maximum write size</p>
<p>This function sets a hint on the maximum write size, similar to the maximum read size set in <a class="el" href="group__development-cbuf.html#ga82522b71b0c0bbe512795f1d57b5d402">cbuf_set_hint_max_read_size()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer </td></tr>
    <tr><td class="paramname">hint_max_write_size</td><td>a hint on the maximum write size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
any other value indicates an error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__development-cbuf.html#ga82522b71b0c0bbe512795f1d57b5d402">cbuf_set_hint_max_read_size()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6476fda2a4b1388367f74d80947068cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cbuf_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcbuf.html">cbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy data into the buffer</p>
<p><code>size</code> bytes of data are taken from <code>data</code> and copied into the buffer. You need to check if the buffer has enough space available by calling <a class="el" href="group__development-cbuf.html#ga146839d85f4314d7aac1d55fa6721945">cbuf_free_level()</a> before; this function call fails with a return value of -ENOMEM if not enough space is available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer </td></tr>
    <tr><td class="paramname">data</td><td>the data to be copied into the buffer </td></tr>
    <tr><td class="paramname">size</td><td>the number of bytes copied from <code>data</code> into the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-EINVAL if the buffer does not have enough space available. No data has been copied. </dd>
<dd>
any other value indicates an error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__development-cbuf.html#gae6eb82f033f4cdbc097b75b7a2726c1d">cbuf_reserve()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae6eb82f033f4cdbc097b75b7a2726c1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cbuf_reserve </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcbuf.html">cbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserve space in the buffer and return a pointer to it</p>
<p>This function reserves <code>size</code> bytes of memory inside the buffer and returns the pointer <code>data</code> to it. This pointer can then be used to write up to <code>size</code> bytes of data to it. After the data has been written, the data needs to be committed by calling <a class="el" href="group__development-cbuf.html#gaaaa163f966a58e2127cb7690971b87d9">cbuf_commit()</a>. You may commit less bytes than you reserved (or even nothing at all).</p>
<p>You need to check if enough space is available by calling <a class="el" href="group__development-cbuf.html#ga146839d85f4314d7aac1d55fa6721945">cbuf_free_level()</a> beforehand, otherwise this function will fail with a -ENOMEM return value.</p>
<p>The main use case for this API are other APIs: many libraries provide functions which can be passed a pointer to a preallocated chunk of memory and a maximum size and then fill this memory. Using the <a class="el" href="group__development-cbuf.html#ga6476fda2a4b1388367f74d80947068cd">cbuf_write()</a> function would require another memory copy (once from the API to a temporary buffer, then from the temporary buffer to this buffer), which can be avoided by using the reserve/commit API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>pointer which can be filled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>maximum number of bytes which can be written to <code>data</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-EINVAL if the buffer does not have enough space available, the reservation is not possible. </dd>
<dd>
-EINVAL the allocation of a temporary buffer failed </dd>
<dd>
any other value indicates an error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__development-cbuf.html#gaaaa163f966a58e2127cb7690971b87d9">cbuf_commit()</a> </dd>
<dd>
<a class="el" href="group__development-cbuf.html#ga6476fda2a4b1388367f74d80947068cd">cbuf_write()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaaa163f966a58e2127cb7690971b87d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cbuf_commit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcbuf.html">cbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Commit data written into the buffer</p>
<p>After you have reserved space in the buffer by calling <a class="el" href="group__development-cbuf.html#gae6eb82f033f4cdbc097b75b7a2726c1d">cbuf_reserve()</a> and written data to it, use this function to commit the <code>size</code> actually written bytes to the buffer. <code>data</code> must be a pointer returned by <a class="el" href="group__development-cbuf.html#gae6eb82f033f4cdbc097b75b7a2726c1d">cbuf_reserve()</a>, <code>size</code> must be equal or less than the size you reserved in <a class="el" href="group__development-cbuf.html#gae6eb82f033f4cdbc097b75b7a2726c1d">cbuf_reserve()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer </td></tr>
    <tr><td class="paramname">data</td><td>the data to commit </td></tr>
    <tr><td class="paramname">size</td><td>the number of bytes to commit from <code>data</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
any other value indicates an error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__development-cbuf.html#gae6eb82f033f4cdbc097b75b7a2726c1d">cbuf_reserve()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga428bae4afd36291497a6a8d817c8041a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cbuf_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcbuf.html">cbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from the buffer</p>
<p>This copies <code>size</code> bytes of data from the buffer into <code>data</code>. <code>data</code> needs to be large enough to hold <code>size</code> bytes of data.</p>
<p>You need to check the buffer fill level if <code>size</code> bytes of data are available by calling <a class="el" href="group__development-cbuf.html#ga8ad5db0ba023348744c080d1bba08cf2">cbuf_fill_level()</a> beforehand; otherwise this function will fail with a -EINVAL return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer </td></tr>
    <tr><td class="paramname">data</td><td>the data location to copy to </td></tr>
    <tr><td class="paramname">size</td><td>the number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-EINVAL if not enough data is available for reading </dd>
<dd>
any other value indicates an error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__development-cbuf.html#ga2639e46f2942e7e1d37bd6b76d52b4b8">cbuf_peek()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2639e46f2942e7e1d37bd6b76d52b4b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cbuf_peek </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcbuf.html">cbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to data without reading it yet</p>
<p>This function returns a pointer to the buffer from which up to <code>size</code> bytes of data can be read. The data is not yet removed from the buffer, you need to call <a class="el" href="group__development-cbuf.html#gab5e5c250e57ef3838f11d289d243eb77">cbuf_discard()</a> for that.</p>
<p>The buffer needs to have <code>size</code> bytes of data available, check this requirement by calling <a class="el" href="group__development-cbuf.html#ga8ad5db0ba023348744c080d1bba08cf2">cbuf_fill_level()</a> beforehand; otherwise -EINVAL is returned.</p>
<p>The main reason for this the peek/discard API is compatibility with 3rd-party APIs. Call <a class="el" href="group__development-cbuf.html#ga2639e46f2942e7e1d37bd6b76d52b4b8">cbuf_peek()</a> to get a pointer to some data, call another API's write function for example and pass this pointer, and finally call <a class="el" href="group__development-cbuf.html#gab5e5c250e57ef3838f11d289d243eb77">cbuf_discard()</a> with the number of bytes actually written by the 3rd-party API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>a pointer to the next <code>size</code> bytes of data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of bytes to look ahead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-EINVAL not enough data is available to be read, check <code>size</code> </dd>
<dd>
-ENOMEM the allocation of a temporary buffer failed </dd>
<dd>
any other value indicates an error </dd></dl>

</div>
</div>
<a class="anchor" id="gab5e5c250e57ef3838f11d289d243eb77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cbuf_discard </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcbuf.html">cbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Discard data in the buffer</p>
<p>This function removes (discards) <code>size</code> bytes of data from the buffer. See <a class="el" href="group__development-cbuf.html#ga2639e46f2942e7e1d37bd6b76d52b4b8">cbuf_peek()</a> for further information on how to use this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer </td></tr>
    <tr><td class="paramname">size</td><td>the number of bytes to discard </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-EINVAL not enough data is available to discard, check <code>size</code> </dd>
<dd>
any other value indicates an error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__development-cbuf.html#ga2639e46f2942e7e1d37bd6b76d52b4b8">cbuf_peek()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga658dcd20d427a506c498a8b2795c13a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbuf_is_empty </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcbuf.html">cbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is the buffer empty?</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the buffer is empty, false otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__development-cbuf.html#ga35fc94ab1feed8e622c4463d3988ded4">cbuf_is_full()</a> </dd>
<dd>
<a class="el" href="group__development-cbuf.html#ga146839d85f4314d7aac1d55fa6721945">cbuf_free_level()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga35fc94ab1feed8e622c4463d3988ded4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbuf_is_full </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcbuf.html">cbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is the buffer full?</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the buffer is full, false otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__development-cbuf.html#ga658dcd20d427a506c498a8b2795c13a5">cbuf_is_empty()</a> </dd>
<dd>
<a class="el" href="group__development-cbuf.html#ga8ad5db0ba023348744c080d1bba08cf2">cbuf_fill_level()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ad5db0ba023348744c080d1bba08cf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cbuf_fill_level </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcbuf.html">cbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the fill level of the buffer</p>
<p>The fill level is equal to the number of bytes of valid data stored in the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of valid bytes in the buffer</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__development-cbuf.html#ga146839d85f4314d7aac1d55fa6721945">cbuf_free_level()</a> </dd>
<dd>
<a class="el" href="group__development-cbuf.html#ga35fc94ab1feed8e622c4463d3988ded4">cbuf_is_full()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga146839d85f4314d7aac1d55fa6721945"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cbuf_free_level </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcbuf.html">cbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of available spaces in the buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that can still be written into the buffer</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__development-cbuf.html#ga8ad5db0ba023348744c080d1bba08cf2">cbuf_fill_level()</a> </dd>
<dd>
<a class="el" href="group__development-cbuf.html#ga658dcd20d427a506c498a8b2795c13a5">cbuf_is_empty()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaac061fbaf4eac2127aee5ac2bfa5177a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cbuf_wait_for_level_change </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcbuf.html">cbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait until the buffer fill level changes</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
any other value indicates an error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__development-cbuf.html#ga9872126868ffb2148641c85cda6e79cc">cbuf_timedwait_for_level_change()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9872126868ffb2148641c85cda6e79cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cbuf_timedwait_for_level_change </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcbuf.html">cbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait until the buffer fill level changes with a timeout</p>
<p>The timeout expires when the absolute time in <code>abs_timeout</code> passes, or if the absolute time specified in <code>abs_timeout</code> has already passed. This behavior is identical to the timed pthread functions (pthread_mutex_timedlock(), etc.).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer </td></tr>
    <tr><td class="paramname">abs_timeout</td><td>if this absolute time passes, the timeout expires </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
any other value indicates an error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__development-cbuf.html#gaac061fbaf4eac2127aee5ac2bfa5177a">cbuf_wait_for_level_change()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Jan 3 2016 15:08:21 for glip by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
