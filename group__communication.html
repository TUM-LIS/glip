<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>glip: Communication</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">glip
   &#160;<span id="projectnumber">0.1.0-dev</span>
   </div>
   <div id="projectbrief">The Generic Logic Interfacing Project</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>GLIP&#160;Introduction</span></a></li>
      <li><a href="modules.html"><span>Documentation</span></a></li>
      <li><a href="download.html"><span>Download</span></a></li>
      <li><a href="contact.html"><span>Contact</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__communication.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Communication</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8d3acecf7e186015a6984688d67557e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__communication.html#ga8d3acecf7e186015a6984688d67557e2">glip_logic_reset</a> (struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *ctx)</td></tr>
<tr class="separator:ga8d3acecf7e186015a6984688d67557e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e5385d600d1df1263517b1879cddaaf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__communication.html#ga2e5385d600d1df1263517b1879cddaaf">glip_read</a> (struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *ctx, uint32_t channel, size_t size, uint8_t *data, size_t *size_read)</td></tr>
<tr class="separator:ga2e5385d600d1df1263517b1879cddaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b923b2ec2a94d33410d679199b61884"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__communication.html#ga1b923b2ec2a94d33410d679199b61884">glip_read_b</a> (struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *ctx, uint32_t channel, size_t size, uint8_t *data, size_t *size_read, unsigned int timeout)</td></tr>
<tr class="separator:ga1b923b2ec2a94d33410d679199b61884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87f8bbfaaef05448065ac910ee9f43d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__communication.html#ga87f8bbfaaef05448065ac910ee9f43d6">glip_write</a> (struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *ctx, uint32_t channel, size_t size, uint8_t *data, size_t *size_written)</td></tr>
<tr class="separator:ga87f8bbfaaef05448065ac910ee9f43d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b3737ebb2d1f601f0c987cf50f0c43a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__communication.html#ga7b3737ebb2d1f601f0c987cf50f0c43a">glip_write_b</a> (struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *ctx, uint32_t channel, size_t size, uint8_t *data, size_t *size_written, unsigned int timeout)</td></tr>
<tr class="separator:ga7b3737ebb2d1f601f0c987cf50f0c43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The main purpose of GLIP is to communicate with a target device. Two main categories of communication exist: control and data communication.</p>
<p><b>Control communication</b> is done by the following functions:</p>
<ul>
<li>glip_reset()</li>
</ul>
<p><b>Data communication</b>, i.e. reading and writing data from and to the device, is done by these functions:</p>
<ul>
<li><a class="el" href="group__communication.html#ga2e5385d600d1df1263517b1879cddaaf">glip_read()</a> and <a class="el" href="group__communication.html#ga1b923b2ec2a94d33410d679199b61884">glip_read_b()</a></li>
<li><a class="el" href="group__communication.html#ga87f8bbfaaef05448065ac910ee9f43d6">glip_write()</a> and <a class="el" href="group__communication.html#ga7b3737ebb2d1f601f0c987cf50f0c43a">glip_write_b()</a></li>
</ul>
<p>All data communication functions need to be given the channel on which the communication should occur.</p>
<p>The GLIP API is modeled after a FIFO interface. This essentially means two things:</p>
<ul>
<li>There are no latency guarantees or acknowledgements: when you call one of the write functions, the data is queued to be transferred to the device. You don't know when or if it will arrive there. When you read from the device, you don't know when the data has been sent (and the device does not know when you read it).</li>
<li>Just like in a regular FIFO, the data ordering is preserved. Whatever data you write first will reach the target first.</li>
</ul>
<p>The read and write functions offer two types of API: a non-blocking API (<a class="el" href="group__communication.html#ga2e5385d600d1df1263517b1879cddaaf">glip_read()</a> and <a class="el" href="group__communication.html#ga87f8bbfaaef05448065ac910ee9f43d6">glip_write()</a>) and a blocking API (<a class="el" href="group__communication.html#ga1b923b2ec2a94d33410d679199b61884">glip_read_b()</a> and <a class="el" href="group__communication.html#ga7b3737ebb2d1f601f0c987cf50f0c43a">glip_write_b()</a>). The <b>non-blocking API functions</b> return immediately with the data written to or read from an internal buffer inside GLIP. Since not enough data might be available for reading or not enough buffer space available for writing data, only a part of the requested data size could have been read or written. The amount of data actually processed is returned as <code>size_read</code> resp. <code>size_written</code>. The non-blocking API fits well into a polling style application which might e.g. poll the library for new data using an already existing event loop (like in GUI applications).</p>
<p>The <b>blocking API functions</b> on the other hand wait until all requested data has been read or written, i.e. if the internal buffers are full (for writes) or empty (for reads), the functions wait until further writing or reading is possible to transfer the requested amount of data. All blocking functions support a <code>timeout</code> parameter. A value of <code>0</code> blocks an unlimited amount of time, any other value makes the function abort after an specified amount of time, even if not all data has been transferred yet. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga8d3acecf7e186015a6984688d67557e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int glip_logic_reset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send reset signal to the user logic</p>
<p>This function enables the ctrl_logic_rst output signal of the GLIP hardware module. It is up to the hardware designer to use this signal for any purpose. Usually, this means only the attached logic is reset, not the the communication with the host PC, even though the signal can be used to create such functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the library context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the call was successful, or an error code if something went wrong </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e5385d600d1df1263517b1879cddaaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int glip_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size_read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read from the target device FIFO on a given channel</p>
<p>Requests to read <code>size</code> bytes of data from channel <code>channel</code> into the variable <code>data</code>. The number of bytes actually read from the target is stored in the <code>size_read</code> output argument.</p>
<p>This function returns 0 if the call was successful; a nonzero return value indicates an error.</p>
<p>Note: You need to allocate sufficient space to read <code>size</code> bytes into <code>data</code> before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the library context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>the channel to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of bytes to read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>the data read from the target (allocated by the user) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size_read</td><td>the number of bytes actually read from the target. Only those bytes may be considered valid inside <code>data!</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the call was successful, or an error code if something went wrong </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b923b2ec2a94d33410d679199b61884"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int glip_read_b </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blocking read from the target device FIFO on a given channel</p>
<p>This function is similar to <a class="el" href="group__communication.html#ga2e5385d600d1df1263517b1879cddaaf">glip_read()</a>, but instead of returning whatever amount of data is available and returning immediately, it blocks until either the requested amount of data is available or the timeout is hit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the library context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>the channel to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of bytes to read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>the data read from the target (allocated by the user) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size_read</td><td>the number of bytes actually read from the target. Only those bytes may be considered valid inside <code>data!</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>the timeout in milliseconds (ms) after which this function gives up reading, i.e. the maximum blocking time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the call was successful and <code>size</code> bytes have been read </dd>
<dd>
-ETIMEDOUT if the call timed out (some data might still have been read, see <code>size_read</code>) </dd>
<dd>
any other value indicates an error</dd></dl>
<p>Note: You need to allocate sufficient space to read <code>size</code> bytes into <code>data</code> before calling this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__communication.html#ga2e5385d600d1df1263517b1879cddaaf">glip_read()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga87f8bbfaaef05448065ac910ee9f43d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int glip_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size_written</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data to the target FIFO on a given channel</p>
<p>Request the transfer of <code>size</code> bytes of <code>data</code> to the target FIFO of channel <code>channel</code>. The actual number of written bytes is returned as <code>size_written</code>. Always check if all data was transferred, and repeat the transfer if this is not the case.</p>
<p>This function returns 0 if the call was successful; a nonzero return value indicates an error.</p>
<p>This function behaves like you would expect from a FIFO with no latency guarantees. This function is non-blocking. There are no write acknowledgements; the data is scheduled to be transferred "soon", whereas the definition of "soon" depends on the used backend. The backend is free to do with the data whatever it wants, as long as the following guarantees are obeyed:</p>
<ul>
<li><code>size_written</code> bytes of <code>data</code> will eventually reach the target device</li>
<li>the data ordering is preserved; the first byte written will be the first byte read from the FIFO</li>
</ul>
<p>All data transfer is <b>big endian</b>. This means for a 2 byte wide FIFO (check the FIFO width with <a class="el" href="group__utilities.html#gae623dbeabb186d94181639509cdc212f">glip_get_fifo_width()</a>) the first byte written will be the MSB in the FIFO, the second byte written will be the LSB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the library context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>the channel to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of bytes to write (length of data) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data to write </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size_written</td><td>the number of bytes actually written; repeat the transfer for the remaining data if </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the call was successful </dd>
<dd>
any other value indicates an error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__communication.html#ga7b3737ebb2d1f601f0c987cf50f0c43a">glip_write_b()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7b3737ebb2d1f601f0c987cf50f0c43a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int glip_write_b </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size_written</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blocking write to the target FIFO on a given channel</p>
<p>This function is the blocking version of <a class="el" href="group__communication.html#ga87f8bbfaaef05448065ac910ee9f43d6">glip_write()</a>. The function returns not before either all data is written (i.e. <code>size</code> bytes) or <code>timeout</code> milliseconds passed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the library context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>the channel to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of bytes to write (length of data) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data to write </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size_written</td><td>the number of bytes actually written; repeat the transfer for the remaining data if </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>the timeout in milliseconds (ms) after which this function gives up writing, i.e. the maximum blocking time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the call was successful and <code>size</code> bytes have been written </dd>
<dd>
-ETIMEDOUT if the call timed out (some data might still have been written, see <code>size_written</code>) </dd>
<dd>
any other value indicates an error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__communication.html#ga87f8bbfaaef05448065ac910ee9f43d6">glip_write()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon May 11 2015 09:19:52 for glip by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
