<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>glip: glip_backend_if Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">glip
   &#160;<span id="projectnumber">0.1.0-dev</span>
   </div>
   <div id="projectbrief">The Generic Logic Interfacing Project</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>GLIP&#160;Introduction</span></a></li>
      <li><a href="modules.html"><span>Documentation</span></a></li>
      <li><a href="download.html"><span>Download</span></a></li>
      <li><a href="contact.html"><span>Contact</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structglip__backend__if.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">glip_backend_if Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="glip-protected_8h_source.html">glip-protected.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a38a24f1f1eeb40152dc1d6dc3e5ae7e5"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglip__backend__if.html#a38a24f1f1eeb40152dc1d6dc3e5ae7e5">open</a> )(struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *, unsigned int)</td></tr>
<tr class="separator:a38a24f1f1eeb40152dc1d6dc3e5ae7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf35df29ea6fdfdc4c9cd40cf3503c8b"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglip__backend__if.html#abf35df29ea6fdfdc4c9cd40cf3503c8b">close</a> )(struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *)</td></tr>
<tr class="separator:abf35df29ea6fdfdc4c9cd40cf3503c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8206f012e10547f0c1ce15e0558202"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglip__backend__if.html#ada8206f012e10547f0c1ce15e0558202">logic_reset</a> )(struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *)</td></tr>
<tr class="separator:ada8206f012e10547f0c1ce15e0558202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ecebe9be7480d9ddc06da95b6c15c4"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglip__backend__if.html#a83ecebe9be7480d9ddc06da95b6c15c4">read</a> )(struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *, uint32_t, size_t, uint8_t *, size_t *)</td></tr>
<tr class="separator:a83ecebe9be7480d9ddc06da95b6c15c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2405f4fc69c626c8f8063c34d9ca2d45"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglip__backend__if.html#a2405f4fc69c626c8f8063c34d9ca2d45">read_b</a> )(struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *, uint32_t, size_t, uint8_t *, size_t *, unsigned int)</td></tr>
<tr class="separator:a2405f4fc69c626c8f8063c34d9ca2d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0be00be258f5fb4b31d2dddc7bc198"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglip__backend__if.html#a3b0be00be258f5fb4b31d2dddc7bc198">write</a> )(struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *, uint32_t, size_t, uint8_t *, size_t *)</td></tr>
<tr class="separator:a3b0be00be258f5fb4b31d2dddc7bc198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50eb84f588c9bbb57da14ee4f834e3d1"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglip__backend__if.html#a50eb84f588c9bbb57da14ee4f834e3d1">write_b</a> )(struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *, uint32_t, size_t, uint8_t *, size_t *, unsigned int)</td></tr>
<tr class="separator:a50eb84f588c9bbb57da14ee4f834e3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77be6e53ae39e862ad19ec744863522a"><td class="memItemLeft" align="right" valign="top">unsigned int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglip__backend__if.html#a77be6e53ae39e862ad19ec744863522a">get_fifo_width</a> )(struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *)</td></tr>
<tr class="separator:a77be6e53ae39e862ad19ec744863522a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecd68114aa629e6f4c8d1073ce720fb"><td class="memItemLeft" align="right" valign="top">unsigned int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglip__backend__if.html#a5ecd68114aa629e6f4c8d1073ce720fb">get_channel_count</a> )(struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *)</td></tr>
<tr class="separator:a5ecd68114aa629e6f4c8d1073ce720fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>GLIP backend interface</p>
<p>All functions in this struct need to be implemented by all backends. In addition, each backend needs to provide an init() function to set up this struct of backend functions. </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="a38a24f1f1eeb40152dc1d6dc3e5ae7e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* glip_backend_if::open) (struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *, unsigned int)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open the connection to the target</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the library context </td></tr>
    <tr><td class="paramname">num_channels</td><td>the number of channels to open </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the call was successful, or an error code if something went wrong</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection-handling.html#ga320064ab9be659d9fbaf52e5d0ab7c13">glip_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abf35df29ea6fdfdc4c9cd40cf3503c8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* glip_backend_if::close) (struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the connection to the target</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the library context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the call was successful, or an error code if something went wrong</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection-handling.html#ga8ed7056352d3bec635eedf393f996d2a">glip_close()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ada8206f012e10547f0c1ce15e0558202"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* glip_backend_if::logic_reset) (struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a reset signal to the target</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the library context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the call was successful, or an error code if something went wrong</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__communication.html#ga8d3acecf7e186015a6984688d67557e2">glip_logic_reset()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a83ecebe9be7480d9ddc06da95b6c15c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* glip_backend_if::read) (struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *, uint32_t, size_t, uint8_t *, size_t *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read from the target device FIFO on a given channel</p>
<p>Requests to read <code>size</code> bytes of data from channel <code>channel</code> into the variable <code>data</code>. The number of bytes actually read from the target is stored in the <code>size_read</code> output argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the library context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>the channel to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of bytes to read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>the data read from the target (preallocated) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size_read</td><td>the number of bytes actually read from the target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the call was successful, or an error code if something went wrong</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__communication.html#ga2e5385d600d1df1263517b1879cddaaf">glip_read()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2405f4fc69c626c8f8063c34d9ca2d45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* glip_backend_if::read_b) (struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *, uint32_t, size_t, uint8_t *, size_t *, unsigned int)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blocking read from the target device FIFO on a given channel</p>
<p>Requests to read <code>size</code> bytes of data from channel <code>channel</code> into the variable <code>data</code>. The number of bytes actually read from the target is stored in the <code>size_read</code> output argument. The function returns if either <code>timeout</code> milliseconds (ms) are exceeded or if <code>size</code> bytes have been read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the library context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>the channel to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of bytes to read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>the data read from the target (preallocated) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size_read</td><td>the number of bytes actually read from the target </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>the timeout [ms] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the call was successful, or an error code if something went wrong</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__communication.html#ga1b923b2ec2a94d33410d679199b61884">glip_read_b()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3b0be00be258f5fb4b31d2dddc7bc198"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* glip_backend_if::write) (struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *, uint32_t, size_t, uint8_t *, size_t *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data to the target FIFO on a given channel</p>
<p>Try to transfer transfer of <code>size</code> bytes of <code>data</code> to the target FIFO of channel <code>channel</code>. The actual number of written bytes is returned as <code>size_written</code>.</p>
<p>This function behaves like you would expect from a FIFO with no latency guarantees. This function is non-blocking. There are no write acknowledgements; the data is scheduled to be transferred "soon", whereas the definition of "soon" depends on the used backend. The backend is free to do with the data whatever it wants, as long as the following guarantees are obeyed:</p>
<ul>
<li><code>size_written</code> bytes of <code>data</code> will eventually reach the target device</li>
<li>the data ordering is preserved; the first byte written will be the first byte read from the FIFO</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the library context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>the channel to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of bytes to write (length of data) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data to write </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size_written</td><td>the number of bytes actually written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the call was successful, or an error code if something went wrong</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__communication.html#ga87f8bbfaaef05448065ac910ee9f43d6">glip_write()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a50eb84f588c9bbb57da14ee4f834e3d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* glip_backend_if::write_b) (struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *, uint32_t, size_t, uint8_t *, size_t *, unsigned int)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blocking write of data to the target FIFO on a given channel</p>
<p>This function is similar to the non-blocking write, <a class="el" href="structglip__backend__if.html#a3b0be00be258f5fb4b31d2dddc7bc198">write()</a>, but it blocks until all <code>size</code> bytes are scheduled to be transferred, or until the timeout of <code>timeout</code> milliseconds (ms) is exceeded.</p>
<p>Note that "scheduled to be transferred" does only mean that the data is safely buffered and will be transferred "soon", but <em>not</em> that it has been received by the target device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the library context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>the channel to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of bytes to write (length of data) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data to write </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size_written</td><td>the number of bytes actually written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>the amount of time in milliseconds (ms) to wait before returning to the caller. Use the value 0 for an unlimited amount of time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the call was successful, or an error code if something went wrong </dd></dl>

</div>
</div>
<a class="anchor" id="a77be6e53ae39e862ad19ec744863522a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int(* glip_backend_if::get_fifo_width) (struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the width of the FIFO on the logic side in bytes</p>
<p>Depending on the used backend and possibly the logic configuration different FIFO widths on the logic side are possible. Data is always transferred in chunks of at least one FIFO width, so make sure to always transfer at least as many bytes as the FIFO is wide.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the library context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the width of the FIFO on the target side in bytes</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__utilities.html#gae623dbeabb186d94181639509cdc212f">glip_get_fifo_width()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5ecd68114aa629e6f4c8d1073ce720fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int(* glip_backend_if::get_channel_count) (struct <a class="el" href="structglip__ctx.html">glip_ctx</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of supported channels</p>
<p>Depending on the backend (and possibly the target device) a different number of channels might be supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the library contexxt </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of supported channels</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__utilities.html#ga8c80f7fce50984f563256636e067677c">glip_get_channel_count()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="glip-protected_8h_source.html">glip-protected.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structglip__backend__if.html">glip_backend_if</a></li>
    <li class="footer">Generated on Wed Jul 8 2015 09:51:19 for glip by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
